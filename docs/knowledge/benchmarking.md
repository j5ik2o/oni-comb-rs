# ベンチマークのガイドライン

## 基本原則

- ベンチマークは実際のユースケースを反映した多様なテストデータを使用する
- 単純なケースから複雑なケースまで、様々な複雑さのデータを用意する
- 複数の実装を比較する場合は、同じ条件でベンチマークを実行する
- ベンチマーク結果は保存して、時系列での比較ができるようにする

## JSONパーサーベンチマークの知見

### パーサーライブラリの特性

1. **nom**
   - 単純なデータ型（bool, number, string）で最も高速（ナノ秒単位）
   - 複雑なJSONデータでも高いパフォーマンスを維持
   - バイトレベルでの処理に最適化されている

2. **pom**
   - 中程度のパフォーマンス（マイクロ秒単位）
   - 文法が直感的で実装しやすい
   - 中規模のデータ処理に適している

3. **oni-comb-rs**
   - 比較的低速（マイクロ秒単位）
   - 柔軟性が高く、複雑な文法を表現しやすい
   - 大規模なデータ処理では最適化が必要

### データ複雑さとパフォーマンスの関係

- データの複雑さが増すにつれて、パーサー間のパフォーマンス差が拡大する
- 単純なデータ型では差が小さいが、ネストされた複雑なデータでは大きな差が生じる
- 特に再帰的な構造（配列やオブジェクトのネスト）の処理で差が顕著になる

### ベンチマーク改善のポイント

- **多様なテストデータ**: 単純な値から複雑なネスト構造まで、様々なケースを用意
- **完全なパーサー使用**: 部分的な機能ではなく、完全なパーサーを使用してベンチマーク
- **結果の保存**: 日時付きのファイルに結果を保存し、時系列での比較を可能に
- **エラー処理の考慮**: 正常系だけでなく、エラーケースのパフォーマンスも測定

## ベンチマーク実行方法

```bash
# ベンチマークの実行
./run-benchmark.sh

# 結果は benchmark_results ディレクトリに保存される
# フラムグラフは target/criterion/ ディレクトリに生成される
```

## 今後の改善提案

1. **メモリ使用量の測定**: パフォーマンスだけでなく、メモリ効率も重要な指標
2. **エラー処理のベンチマーク**: 不正なデータに対する処理性能の測定
3. **並列処理の検討**: 大規模データ処理のための並列化オプションの評価