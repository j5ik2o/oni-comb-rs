# ベンチマークのガイドライン

## 基本原則

- ベンチマークは実際のユースケースを反映した多様なテストデータを使用する
- 単純なケースから複雑なケースまで、様々な複雑さのデータを用意する
- 複数の実装を比較する場合は、同じ条件でベンチマークを実行する
- ベンチマーク結果は保存して、時系列での比較ができるようにする

## JSONパーサーベンチマークの知見

### パーサーライブラリの特性

1. **nom**
   - 単純なデータ型（bool, number, string）で最も高速（ナノ秒単位）
   - 複雑なJSONデータでも高いパフォーマンスを維持（6.4μs）
   - バイトレベルでの処理に最適化されている
   - 文字列を直接処理し、メモリ割り当てを最小限に抑える

2. **pom**
   - 中程度のパフォーマンス（マイクロ秒単位）
   - 複雑なJSONデータでは305μs程度
   - 文法が直感的で実装しやすい
   - 中規模のデータ処理に適している

3. **oni-comb-rs**
   - 最適化前は比較的低速（マイクロ秒〜ミリ秒単位）
   - 最適化後は大幅に改善（マイクロ秒単位）
   - 複雑なJSONデータでは774μs程度（最適化後）
   - 柔軟性が高く、複雑な文法を表現しやすい
   - キャッシュの活用とメモリ割り当ての最小化で大幅な改善が可能

### oni-comb-rsの最適化結果

| データ型      | 最適化前  | 最適化後  | 改善率 |
|--------------|----------|----------|-------|
| bool         | 76.7μs   | 11.3μs   | 85%   |
| number       | 82.2μs   | 11.7μs   | 86%   |
| string       | 82.3μs   | 12.9μs   | 84%   |
| simple_array | 492.7μs  | 69.6μs   | 86%   |
| simple_object| 336.3μs  | 58.3μs   | 83%   |
| nested_object| 681.8μs  | 122.2μs  | 82%   |
| complex      | 3.7ms    | 773.8μs  | 79%   |

主な最適化手法：
1. **キャッシュの活用**: 再帰的なパーサーや複数回使用されるパーサーに `.cache()` を追加
2. **メモリ割り当ての最小化**: 不要なメモリ割り当てを減らす（例：`map(Clone::clone)` → `map(|c| *c)`）
3. **パーサーの最適化**: 最も頻度の高いパーサーから順に試すように順序を調整

### データ複雑さとパフォーマンスの関係

- データの複雑さが増すにつれて、パーサー間のパフォーマンス差が拡大する
- 単純なデータ型では差が小さいが、ネストされた複雑なデータでは大きな差が生じる
- 特に再帰的な構造（配列やオブジェクトのネスト）の処理で差が顕著になる

### ベンチマーク改善のポイント

- **多様なテストデータ**: 単純な値から複雑なネスト構造まで、様々なケースを用意
- **完全なパーサー使用**: 部分的な機能ではなく、完全なパーサーを使用してベンチマーク
- **結果の保存**: 日時付きのファイルに結果を保存し、時系列での比較を可能に
- **エラー処理の考慮**: 正常系だけでなく、エラーケースのパフォーマンスも測定

## ベンチマーク実行方法

```bash
# ベンチマークの実行
./run-benchmark.sh

# 結果は benchmark_results ディレクトリに保存される
# フラムグラフは target/criterion/ ディレクトリに生成される
```

## 今後の改善提案

1. **メモリ使用量の測定**: パフォーマンスだけでなく、メモリ効率も重要な指標
2. **エラー処理のベンチマーク**: 不正なデータに対する処理性能の測定
3. **並列処理の検討**: 大規模データ処理のための並列化オプションの評価